struct Action {

}

struct State{
    
}

struct History{

}

State sample_from_belief(Belief b){

}

Action action_prog_widen(History h){
    if(C_h.size() <= k_a * std::pow(N(h), alpha_a)){
        Action a = next_action(h);
        C_h.append(a);
    }
    Action best_a;
    double best_reward = -INFINITY;
    for(Action a : C_h){
        double reward = Q(h.append(a)) + c * std::sqrt(std::log(N(h))/ N(h.append(a)));

        // N: a count of the number of visits.
        // M: a count of the number of times that a history has been generated by the model.
        if (reward > best_reward){
            best_a = a;
        }
    }
    return best_a;
}

struct GenerativeResult{
    State s_tilde;
    Observation o;
    double reward;
}
int d_max = 5;


simulate_pomcp_dpw(State s, History h, int d){
    if (d == 0) return 0;
    Action a = action_prog_widen(h);
    if (C(ha).size() <= k_o * std::pow(N(ha), alpha_o)){
        GenerativeResult generative_result = G(s, a);
        C(ha) = C(ha) + {o};
        M(hao) = M(hao) + 1
        B(hap).append(generative_result.s_tilde);
        if (M(hao) == 1){
            total = generative_result.r + gamma * rollout(generative_result.s_tilde, hao, d - 1);
        } else {
            total = generative_result.r + gamma * simulate_pomcp_dpw(generative_result.s_tilde, hao, d - 1);
        }
    }else{ // observation is rejected
    // tree search is continued with an observation selected in proportion to the number of times
        Observation o = select_wp(C(ha), M(hao)/M_sum_o(hao)); // select observation, with respective to M
        State s_tilde =  select_wp(B(ha), 1/B_sum_o(hao)); // sample a belief
        r = R(s, a, s_tilde); // calculate reward
        total = r + gamma * simulate_pomcp_dpw(s_tilde, hao, d - 1);
         
        r = R(s, a, s_tilde);
    }
    N(h) = N(h) + 1;
    N(ha) = N(ha) + 1;
    Q(ha) = Q(ha) + (total - Q(ha) / N(ha));
}
Action Plan(Belief b){
    for(int i = 0; i < n; i++){
        State s = sample_from_belief(b);
        simulate_pomcp_dpw(s, b, d_max);
    }
}

int main(){

}


